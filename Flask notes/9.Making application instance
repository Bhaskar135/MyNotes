    4) Making application instance
     #app/__init__.py
     from flask import Flask,render_template
     from flask_bootstrap import Bootstrap
     from flask_mail import Mail
     from flask_moment import Moment
     from flask_sqlalchemy import SQLAlchemy
     from config import config

     bootstrap=Bootstrap()       # Uninitialized by passing no arguments
     mail=Mail()
     moment=Moment()
     db=SQLAlchemy()

     def create_app(config_name):
    	app=Flask(__name__)
    	app.config.from_object(config[config_name])   # The application initialization is now done by using from_object() method from the Flask 							# configuration object 
    	config[config_name].init_app(app)
    	bootstrap.init_app(app)       # initialized 
    	mail.init_app(app)
    	moment.init_app(app)
    	db.init_app(app)
    	
        # attach routes and custom error pages here
    	
        return app

    5) Using blueprints to define routes and error handlers.
    # app/main/__init__.py
    from flask import Blueprint
    main = Blueprint('main', __name__)	  # 1st argument is blueprint name and 2nd argument is the module or package where the blueprint is located.
    from .import views, errors

	These are in inactive state until the blueprint is registered with an application. Importing views.py and errors.py in it causes the routes   and error handlers to be associated with the blueprint.

    Note : i) from .import <module_name>  : Here . represents the current package.
          ii) from ..import <module_name>  : Here .. represents the parrent of the current package.

    6) The blueprint is registered with the application inside te create_app() function :
       # app/__init__.py
       def create_app(config_name):
	   #..........
           from .main import main as main_blueprint
           app.register_blueprint(main_blueprint)
           return app
    
    7) # app/main/errors.py 
       from flask import render_template
       from .import main
       
       @main.app_errorhandler(404)
       def page_not_found(e):
           return render_template('404.html'),404

       @main.app_errorhandler(500)
       def internal_server_error(e):
    	   return render_template('500.html'),500

    8) # app/main/views.py 
    from datetime import datetime
    from flask import render_template, session, redirect, url_for
    from .import main
    from .forms import NameForm
    from ..import db
    from ..models import User,Role

    @main.route('/',methods=['GET','POST'])
    def index():
        form=NameForm()
        if form.validate_on_submit():
            user=User.query.filter_by(username=form.name.data).first()
            if user is None :
                user=User(username=form.name.data)
                db.session.add(user)
                db.session.commit()
                session['known']=False
                if app.config['FLASKY_ADMIN']:
                    send_email(app.config['FLASKY_ADMIN'],'New user','mail/new_user',user=user)
            else:
                session['known']=True
            session['name']=form.name.data
            form.name.data=''
            return redirect(url_for('.index'))   # here '.index' can also be write like 'main.index' where 'main' is the name of the blueprint.
        return render_template('index.html',form=form,name=session.get('name'),known=session.get('known',False),current_time=datetime.utcnow())

     10) pip install flask-wtf
     
     11) # app/main/forms.py
     from flask_wtf import FlaskForm
     from wtforms import StringField, SubmitField
     from wtforms.validators import DataRequired
     
     class NameForm(FlaskForm):
         name=StringField('What is your name ?',validators=[DataRequired()] )
         submit=SubmitField('Submit')

     12) # flasky.py
     import os
     from app import create_app, db
     from app.models import User, Role
     from flask_migrate import Migrate

     app=create_app(os.getenv('FLASK_CONFIG') or 'default')
     migrate=Migrate(app,db)

     @app.shell_context_processor
     def make_shell_context():
         return dict(db=db, User=User, Role=Role)

     @app.cli.command()
     def test():
         """Run the unit tests."""
         import unittest
         tests=unittest.TestLoader().discover('tests')
         unittest.TextTestRunner(verbosity=2).run(tests)

    13) export FLASK_APP=flasky.py
    14) export FLASK_DEBUG=1
    15) We include a requirements.txt file that records all the package dependencies with exact version number.
            pip freeze > requirements.txt
    16) To build a replica of the virtual environment and run the following command on it :
            pip install -r requirements.txt

